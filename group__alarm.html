<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9"/>
	<meta name="generator" content="Doxygen 1.8.17"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>Raspberry Pi Pico SDK: alarm</title>
	<!-- <link href="tabs.css" rel="stylesheet" type="text/css"/> -->
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
	<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
	<link href="doxygen.css" rel="stylesheet" type="text/css" />
	<link href="normalise.css" rel="stylesheet" type="text/css"/>
<link href="main.css" rel="stylesheet" type="text/css"/>
<link href="styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
	<div class="navigation-mobile">
		<div class="logo--mobile">
			<a href="/"><img src="logo-mobile.svg" alt="Raspberry Pi"></a>
		</div>
		<div class="navigation-toggle">
			<span class="line-1"></span>
			<span class="line-2">
				<p>Menu Toggle</p>
			</span>
			<span class="line-3"></span>
		</div>
	</div>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div class="logo">
			<a href="index.html"> <img src="logo.svg" alt="Raspberry Pi"></a>
			<span style="display: inline-block; margin-top: 10px;">
				v1.5.0
			</span>
		</div>
		<div class="navigation-footer">
			<img src="logo-mobile.svg" alt="Raspberry Pi">
			<a href="https://www.raspberrypi.com/" target="_blank">By Raspberry Pi Ltd</a>
		</div>
<!-- 		<div class="search">
			<form>
				<input type="search" name="search" id="search" placeholder="Search">
				<input type="submit" value="Search">
			</form>
		</div> -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__alarm.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">alarm<div class="ingroups"><a class="el" href="group__high__level.html">High Level APIs</a> &raquo; <a class="el" href="group__pico__time.html">pico_time</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Alarm functions for scheduling future execution.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga72314cafa18f7b2f90f9200be136ca27"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#ga72314cafa18f7b2f90f9200be136ca27">PICO_TIME_DEFAULT_ALARM_POOL_DISABLED</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga72314cafa18f7b2f90f9200be136ca27"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1 then the default alarm pool is disabled (so no hardware alarm is claimed for the pool)  <a href="group__alarm.html#ga72314cafa18f7b2f90f9200be136ca27">More...</a><br /></td></tr>
<tr class="separator:ga72314cafa18f7b2f90f9200be136ca27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40b4a03bf9e967d4e7170d20c5c9fb15"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#ga40b4a03bf9e967d4e7170d20c5c9fb15">PICO_TIME_DEFAULT_ALARM_POOL_HARDWARE_ALARM_NUM</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:ga40b4a03bf9e967d4e7170d20c5c9fb15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects which hardware alarm is used for the default alarm pool.  <a href="group__alarm.html#ga40b4a03bf9e967d4e7170d20c5c9fb15">More...</a><br /></td></tr>
<tr class="separator:ga40b4a03bf9e967d4e7170d20c5c9fb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bb3180aa64f3c9af8c521ec1b22bdb2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#ga4bb3180aa64f3c9af8c521ec1b22bdb2">PICO_TIME_DEFAULT_ALARM_POOL_MAX_TIMERS</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:ga4bb3180aa64f3c9af8c521ec1b22bdb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the maximum number of concurrent timers in the default alarm pool.  <a href="group__alarm.html#ga4bb3180aa64f3c9af8c521ec1b22bdb2">More...</a><br /></td></tr>
<tr class="separator:ga4bb3180aa64f3c9af8c521ec1b22bdb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa593548569c182a0d65d2e06a9c3493b"><td class="memItemLeft" align="right" valign="top">typedef int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">alarm_id_t</a></td></tr>
<tr class="memdesc:gaa593548569c182a0d65d2e06a9c3493b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The identifier for an alarm.  <a href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">More...</a><br /></td></tr>
<tr class="separator:gaa593548569c182a0d65d2e06a9c3493b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade88ed45e9b59ad39d91f17c8709c16a"><td class="memItemLeft" align="right" valign="top">typedef int64_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#gade88ed45e9b59ad39d91f17c8709c16a">alarm_callback_t</a>) (<a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">alarm_id_t</a> id, void *user_data)</td></tr>
<tr class="memdesc:gade88ed45e9b59ad39d91f17c8709c16a"><td class="mdescLeft">&#160;</td><td class="mdescRight">User alarm callback.  <a href="group__alarm.html#gade88ed45e9b59ad39d91f17c8709c16a">More...</a><br /></td></tr>
<tr class="separator:gade88ed45e9b59ad39d91f17c8709c16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab363026fa15b43405538eb087ee7cfa9"><td class="memItemLeft" align="right" valign="top"><a id="gab363026fa15b43405538eb087ee7cfa9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#gab363026fa15b43405538eb087ee7cfa9">alarm_pool_init_default</a> (void)</td></tr>
<tr class="memdesc:gab363026fa15b43405538eb087ee7cfa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the default alarm pool (if not already created or disabled) <br /></td></tr>
<tr class="separator:gab363026fa15b43405538eb087ee7cfa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eb49d6478d51b0507d7f0bc2334374f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalarm__pool.html">alarm_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#ga3eb49d6478d51b0507d7f0bc2334374f">alarm_pool_get_default</a> (void)</td></tr>
<tr class="memdesc:ga3eb49d6478d51b0507d7f0bc2334374f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default alarm pool used when alarms are added without specifying an alarm pool, and also used by the SDK to support lower power sleeps and timeouts.  <a href="group__alarm.html#ga3eb49d6478d51b0507d7f0bc2334374f">More...</a><br /></td></tr>
<tr class="separator:ga3eb49d6478d51b0507d7f0bc2334374f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3caa6c4edd9fc97b5ea4688eabc3545d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalarm__pool.html">alarm_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#ga3caa6c4edd9fc97b5ea4688eabc3545d">alarm_pool_create</a> (uint hardware_alarm_num, uint max_timers)</td></tr>
<tr class="memdesc:ga3caa6c4edd9fc97b5ea4688eabc3545d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an alarm pool.  <a href="group__alarm.html#ga3caa6c4edd9fc97b5ea4688eabc3545d">More...</a><br /></td></tr>
<tr class="separator:ga3caa6c4edd9fc97b5ea4688eabc3545d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3d6256fbd5c3500984704092ae265fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalarm__pool.html">alarm_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#gae3d6256fbd5c3500984704092ae265fc">alarm_pool_create_with_unused_hardware_alarm</a> (uint max_timers)</td></tr>
<tr class="memdesc:gae3d6256fbd5c3500984704092ae265fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an alarm pool, claiming an used hardware alarm to back it.  <a href="group__alarm.html#gae3d6256fbd5c3500984704092ae265fc">More...</a><br /></td></tr>
<tr class="separator:gae3d6256fbd5c3500984704092ae265fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dc626c1e534842c85c3902d212f7eef"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#ga2dc626c1e534842c85c3902d212f7eef">alarm_pool_hardware_alarm_num</a> (<a class="el" href="structalarm__pool.html">alarm_pool_t</a> *pool)</td></tr>
<tr class="memdesc:ga2dc626c1e534842c85c3902d212f7eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hardware alarm used by an alarm pool.  <a href="group__alarm.html#ga2dc626c1e534842c85c3902d212f7eef">More...</a><br /></td></tr>
<tr class="separator:ga2dc626c1e534842c85c3902d212f7eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4918e03a3ddd5c328d65bd014d26856b"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#ga4918e03a3ddd5c328d65bd014d26856b">alarm_pool_core_num</a> (<a class="el" href="structalarm__pool.html">alarm_pool_t</a> *pool)</td></tr>
<tr class="memdesc:ga4918e03a3ddd5c328d65bd014d26856b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the core number the alarm pool was initialized on (and hence callbacks are called on)  <a href="group__alarm.html#ga4918e03a3ddd5c328d65bd014d26856b">More...</a><br /></td></tr>
<tr class="separator:ga4918e03a3ddd5c328d65bd014d26856b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7536c4d34088a2d19b2da92b87cbb4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#gae7536c4d34088a2d19b2da92b87cbb4e">alarm_pool_destroy</a> (<a class="el" href="structalarm__pool.html">alarm_pool_t</a> *pool)</td></tr>
<tr class="memdesc:gae7536c4d34088a2d19b2da92b87cbb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the alarm pool, cancelling all alarms and freeing up the underlying hardware alarm.  <a href="group__alarm.html#gae7536c4d34088a2d19b2da92b87cbb4e">More...</a><br /></td></tr>
<tr class="separator:gae7536c4d34088a2d19b2da92b87cbb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab75446a927e4e870ad27fde145a88019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">alarm_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#gab75446a927e4e870ad27fde145a88019">alarm_pool_add_alarm_at</a> (<a class="el" href="structalarm__pool.html">alarm_pool_t</a> *pool, <a class="el" href="structabsolute__time__t.html">absolute_time_t</a> time, <a class="el" href="group__alarm.html#gade88ed45e9b59ad39d91f17c8709c16a">alarm_callback_t</a> callback, void *user_data, bool fire_if_past)</td></tr>
<tr class="memdesc:gab75446a927e4e870ad27fde145a88019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an alarm callback to be called at a specific time.  <a href="group__alarm.html#gab75446a927e4e870ad27fde145a88019">More...</a><br /></td></tr>
<tr class="separator:gab75446a927e4e870ad27fde145a88019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72bfc8c2dd5bf334cd68af2e349a1b37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">alarm_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#ga72bfc8c2dd5bf334cd68af2e349a1b37">alarm_pool_add_alarm_at_force_in_context</a> (<a class="el" href="structalarm__pool.html">alarm_pool_t</a> *pool, <a class="el" href="structabsolute__time__t.html">absolute_time_t</a> time, <a class="el" href="group__alarm.html#gade88ed45e9b59ad39d91f17c8709c16a">alarm_callback_t</a> callback, void *user_data)</td></tr>
<tr class="memdesc:ga72bfc8c2dd5bf334cd68af2e349a1b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an alarm callback to be called at or after a specific time.  <a href="group__alarm.html#ga72bfc8c2dd5bf334cd68af2e349a1b37">More...</a><br /></td></tr>
<tr class="separator:ga72bfc8c2dd5bf334cd68af2e349a1b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d00072e81de2d54fa690dc4b4bfe408"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">alarm_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#ga0d00072e81de2d54fa690dc4b4bfe408">alarm_pool_add_alarm_in_us</a> (<a class="el" href="structalarm__pool.html">alarm_pool_t</a> *pool, uint64_t us, <a class="el" href="group__alarm.html#gade88ed45e9b59ad39d91f17c8709c16a">alarm_callback_t</a> callback, void *user_data, bool fire_if_past)</td></tr>
<tr class="memdesc:ga0d00072e81de2d54fa690dc4b4bfe408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an alarm callback to be called after a delay specified in microseconds.  <a href="group__alarm.html#ga0d00072e81de2d54fa690dc4b4bfe408">More...</a><br /></td></tr>
<tr class="separator:ga0d00072e81de2d54fa690dc4b4bfe408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e32765c525683f216fc42bd1984e239"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">alarm_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#ga6e32765c525683f216fc42bd1984e239">alarm_pool_add_alarm_in_ms</a> (<a class="el" href="structalarm__pool.html">alarm_pool_t</a> *pool, uint32_t ms, <a class="el" href="group__alarm.html#gade88ed45e9b59ad39d91f17c8709c16a">alarm_callback_t</a> callback, void *user_data, bool fire_if_past)</td></tr>
<tr class="memdesc:ga6e32765c525683f216fc42bd1984e239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an alarm callback to be called after a delay specified in milliseconds.  <a href="group__alarm.html#ga6e32765c525683f216fc42bd1984e239">More...</a><br /></td></tr>
<tr class="separator:ga6e32765c525683f216fc42bd1984e239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02cc23b4a3109fb8c2d57e24981f2932"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#ga02cc23b4a3109fb8c2d57e24981f2932">alarm_pool_cancel_alarm</a> (<a class="el" href="structalarm__pool.html">alarm_pool_t</a> *pool, <a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">alarm_id_t</a> alarm_id)</td></tr>
<tr class="memdesc:ga02cc23b4a3109fb8c2d57e24981f2932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel an alarm.  <a href="group__alarm.html#ga02cc23b4a3109fb8c2d57e24981f2932">More...</a><br /></td></tr>
<tr class="separator:ga02cc23b4a3109fb8c2d57e24981f2932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae98ddd58a2c1d142eb6db7882512ce8d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">alarm_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#gae98ddd58a2c1d142eb6db7882512ce8d">add_alarm_at</a> (<a class="el" href="structabsolute__time__t.html">absolute_time_t</a> time, <a class="el" href="group__alarm.html#gade88ed45e9b59ad39d91f17c8709c16a">alarm_callback_t</a> callback, void *user_data, bool fire_if_past)</td></tr>
<tr class="memdesc:gae98ddd58a2c1d142eb6db7882512ce8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an alarm callback to be called at a specific time.  <a href="group__alarm.html#gae98ddd58a2c1d142eb6db7882512ce8d">More...</a><br /></td></tr>
<tr class="separator:gae98ddd58a2c1d142eb6db7882512ce8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b4481d9d9a906caefb31c54a048575"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">alarm_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#ga69b4481d9d9a906caefb31c54a048575">add_alarm_in_us</a> (uint64_t us, <a class="el" href="group__alarm.html#gade88ed45e9b59ad39d91f17c8709c16a">alarm_callback_t</a> callback, void *user_data, bool fire_if_past)</td></tr>
<tr class="memdesc:ga69b4481d9d9a906caefb31c54a048575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an alarm callback to be called after a delay specified in microseconds.  <a href="group__alarm.html#ga69b4481d9d9a906caefb31c54a048575">More...</a><br /></td></tr>
<tr class="separator:ga69b4481d9d9a906caefb31c54a048575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bb045ab597f773d7d5fdfea5db94f69"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">alarm_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#ga8bb045ab597f773d7d5fdfea5db94f69">add_alarm_in_ms</a> (uint32_t ms, <a class="el" href="group__alarm.html#gade88ed45e9b59ad39d91f17c8709c16a">alarm_callback_t</a> callback, void *user_data, bool fire_if_past)</td></tr>
<tr class="memdesc:ga8bb045ab597f773d7d5fdfea5db94f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an alarm callback to be called after a delay specified in milliseconds.  <a href="group__alarm.html#ga8bb045ab597f773d7d5fdfea5db94f69">More...</a><br /></td></tr>
<tr class="separator:ga8bb045ab597f773d7d5fdfea5db94f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae99f63dc25fe5c3a0d78d9fb90308b1b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#gae99f63dc25fe5c3a0d78d9fb90308b1b">cancel_alarm</a> (<a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">alarm_id_t</a> alarm_id)</td></tr>
<tr class="memdesc:gae99f63dc25fe5c3a0d78d9fb90308b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel an alarm from the default alarm pool.  <a href="group__alarm.html#gae99f63dc25fe5c3a0d78d9fb90308b1b">More...</a><br /></td></tr>
<tr class="separator:gae99f63dc25fe5c3a0d78d9fb90308b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Alarm functions for scheduling future execution. </p>
<p>Alarms are added to alarm pools, which may hold a certain fixed number of active alarms. Each alarm pool utilizes one of four underlying hardware alarms, thus you may have up to four alarm pools. An alarm pool calls (except when the callback would happen before or during being set) the callback on the core from which the alarm pool was created. Callbacks are called from the hardware alarm IRQ handler, so care must be taken in their implementation.</p>
<p>A default pool is created the core specified by PICO_TIME_DEFAULT_ALARM_POOL_HARDWARE_ALARM_NUM on core 0, and may be used by the method variants that take no alarm pool parameter.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structalarm__pool.html">alarm_pool</a> </dd>
<dd>
<a class="el" href="group__hardware__timer.html" title="Low-level hardware timer API.">hardware_timer</a> </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga72314cafa18f7b2f90f9200be136ca27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72314cafa18f7b2f90f9200be136ca27">&#9670;&nbsp;</a></span>PICO_TIME_DEFAULT_ALARM_POOL_DISABLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PICO_TIME_DEFAULT_ALARM_POOL_DISABLED&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If 1 then the default alarm pool is disabled (so no hardware alarm is claimed for the pool) </p>
<dl class="section note"><dt>Note</dt><dd>Setting to 1 may cause some code not to compile as default timer pool related methods are removed</dd>
<dd>
When the default alarm pool is disabled, <em>sleep_</em> methods and timeouts are no longer lower powered (they become <em>busy_wait_</em>)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__alarm.html#ga40b4a03bf9e967d4e7170d20c5c9fb15" title="Selects which hardware alarm is used for the default alarm pool.">PICO_TIME_DEFAULT_ALARM_POOL_HARDWARE_ALARM_NUM</a> </dd>
<dd>
<a class="el" href="group__alarm.html#ga3eb49d6478d51b0507d7f0bc2334374f" title="The default alarm pool used when alarms are added without specifying an alarm pool,...">alarm_pool_get_default()</a> </dd></dl>

</div>
</div>
<a id="ga40b4a03bf9e967d4e7170d20c5c9fb15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40b4a03bf9e967d4e7170d20c5c9fb15">&#9670;&nbsp;</a></span>PICO_TIME_DEFAULT_ALARM_POOL_HARDWARE_ALARM_NUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PICO_TIME_DEFAULT_ALARM_POOL_HARDWARE_ALARM_NUM&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects which hardware alarm is used for the default alarm pool. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__alarm.html#ga3eb49d6478d51b0507d7f0bc2334374f" title="The default alarm pool used when alarms are added without specifying an alarm pool,...">alarm_pool_get_default()</a> </dd></dl>

</div>
</div>
<a id="ga4bb3180aa64f3c9af8c521ec1b22bdb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bb3180aa64f3c9af8c521ec1b22bdb2">&#9670;&nbsp;</a></span>PICO_TIME_DEFAULT_ALARM_POOL_MAX_TIMERS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PICO_TIME_DEFAULT_ALARM_POOL_MAX_TIMERS&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects the maximum number of concurrent timers in the default alarm pool. </p>
<dl class="section note"><dt>Note</dt><dd>For implementation reasons this is limited to PICO_PHEAP_MAX_ENTRIES which defaults to 255 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__alarm.html#ga40b4a03bf9e967d4e7170d20c5c9fb15" title="Selects which hardware alarm is used for the default alarm pool.">PICO_TIME_DEFAULT_ALARM_POOL_HARDWARE_ALARM_NUM</a> </dd>
<dd>
<a class="el" href="group__alarm.html#ga3eb49d6478d51b0507d7f0bc2334374f" title="The default alarm pool used when alarms are added without specifying an alarm pool,...">alarm_pool_get_default()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gade88ed45e9b59ad39d91f17c8709c16a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade88ed45e9b59ad39d91f17c8709c16a">&#9670;&nbsp;</a></span>alarm_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64_t(* alarm_callback_t) (<a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">alarm_id_t</a> id, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User alarm callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the alarm_id as returned when the alarm was added </td></tr>
    <tr><td class="paramname">user_data</td><td>the user data passed when the alarm was added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 to reschedule the same alarm this many us from the time the alarm was previously scheduled to fire </dd>
<dd>
&gt;0 to reschedule the same alarm this many us from the time this method returns </dd>
<dd>
0 to not reschedule the alarm </dd></dl>

</div>
</div>
<a id="gaa593548569c182a0d65d2e06a9c3493b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa593548569c182a0d65d2e06a9c3493b">&#9670;&nbsp;</a></span>alarm_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t <a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">alarm_id_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The identifier for an alarm. </p>
<dl class="section note"><dt>Note</dt><dd>this identifier is signed because -1 is used as an error condition when creating alarms</dd>
<dd>
alarm ids may be reused, however for convenience the implementation makes an attempt to defer reusing as long as possible. You should certainly expect it to be hundreds of ids before one is reused, although in most cases it is more. Nonetheless care must still be taken when cancelling alarms or other functionality based on alarms when the alarm may have expired, as eventually the alarm id may be reused for another alarm. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae98ddd58a2c1d142eb6db7882512ce8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae98ddd58a2c1d142eb6db7882512ce8d">&#9670;&nbsp;</a></span>add_alarm_at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">alarm_id_t</a> add_alarm_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structabsolute__time__t.html">absolute_time_t</a>&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__alarm.html#gade88ed45e9b59ad39d91f17c8709c16a">alarm_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fire_if_past</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an alarm callback to be called at a specific time. </p>
<p>Generally the callback is called as soon as possible after the time specified from an IRQ handler on the core of the default alarm pool (generally core 0). If the callback is in the past or happens before the alarm setup could be completed, then this method will optionally call the callback itself and then return a return code to indicate that the target time has passed.</p>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this method from an IRQ handler (including alarm callbacks), and from either core.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>the timestamp when (after which) the callback should fire </td></tr>
    <tr><td class="paramname">callback</td><td>the callback function </td></tr>
    <tr><td class="paramname">user_data</td><td>user data to pass to the callback function </td></tr>
    <tr><td class="paramname">fire_if_past</td><td>if true, and the alarm time falls before or during this call before the alarm can be set, then the callback should be called during (by) this function instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 the alarm id </dd>
<dd>
0 if the alarm time passed before or during the call AND there is no active alarm to return the id of. The latter can either happen because fire_if_past was false (i.e. no timer was ever created), or if the callback <em>was</em> called during this method but the callback cancelled itself by returning 0 </dd>
<dd>
-1 if there were no alarm slots available </dd></dl>

</div>
</div>
<a id="ga8bb045ab597f773d7d5fdfea5db94f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bb045ab597f773d7d5fdfea5db94f69">&#9670;&nbsp;</a></span>add_alarm_in_ms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">alarm_id_t</a> add_alarm_in_ms </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__alarm.html#gade88ed45e9b59ad39d91f17c8709c16a">alarm_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fire_if_past</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an alarm callback to be called after a delay specified in milliseconds. </p>
<p>Generally the callback is called as soon as possible after the time specified from an IRQ handler on the core of the default alarm pool (generally core 0). If the callback is in the past or happens before the alarm setup could be completed, then this method will optionally call the callback itself and then return a return code to indicate that the target time has passed.</p>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this method from an IRQ handler (including alarm callbacks), and from either core.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>the delay (from now) in milliseconds when (after which) the callback should fire </td></tr>
    <tr><td class="paramname">callback</td><td>the callback function </td></tr>
    <tr><td class="paramname">user_data</td><td>user data to pass to the callback function </td></tr>
    <tr><td class="paramname">fire_if_past</td><td>if true, and the alarm time falls during this call before the alarm can be set, then the callback should be called during (by) this function instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 the alarm id </dd>
<dd>
0 if the alarm time passed before or during the call AND there is no active alarm to return the id of. The latter can either happen because fire_if_past was false (i.e. no timer was ever created), or if the callback <em>was</em> called during this method but the callback cancelled itself by returning 0 </dd>
<dd>
-1 if there were no alarm slots available </dd></dl>

</div>
</div>
<a id="ga69b4481d9d9a906caefb31c54a048575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69b4481d9d9a906caefb31c54a048575">&#9670;&nbsp;</a></span>add_alarm_in_us()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">alarm_id_t</a> add_alarm_in_us </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__alarm.html#gade88ed45e9b59ad39d91f17c8709c16a">alarm_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fire_if_past</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an alarm callback to be called after a delay specified in microseconds. </p>
<p>Generally the callback is called as soon as possible after the time specified from an IRQ handler on the core of the default alarm pool (generally core 0). If the callback is in the past or happens before the alarm setup could be completed, then this method will optionally call the callback itself and then return a return code to indicate that the target time has passed.</p>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this method from an IRQ handler (including alarm callbacks), and from either core.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">us</td><td>the delay (from now) in microseconds when (after which) the callback should fire </td></tr>
    <tr><td class="paramname">callback</td><td>the callback function </td></tr>
    <tr><td class="paramname">user_data</td><td>user data to pass to the callback function </td></tr>
    <tr><td class="paramname">fire_if_past</td><td>if true, and the alarm time falls during this call before the alarm can be set, then the callback should be called during (by) this function instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 the alarm id </dd>
<dd>
0 if the alarm time passed before or during the call AND there is no active alarm to return the id of. The latter can either happen because fire_if_past was false (i.e. no timer was ever created), or if the callback <em>was</em> called during this method but the callback cancelled itself by returning 0 </dd>
<dd>
-1 if there were no alarm slots available </dd></dl>

</div>
</div>
<a id="gab75446a927e4e870ad27fde145a88019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab75446a927e4e870ad27fde145a88019">&#9670;&nbsp;</a></span>alarm_pool_add_alarm_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">alarm_id_t</a> alarm_pool_add_alarm_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalarm__pool.html">alarm_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structabsolute__time__t.html">absolute_time_t</a>&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__alarm.html#gade88ed45e9b59ad39d91f17c8709c16a">alarm_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fire_if_past</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an alarm callback to be called at a specific time. </p>
<p>Generally the callback is called as soon as possible after the time specified from an IRQ handler on the core the alarm pool was created on. If the callback is in the past or happens before the alarm setup could be completed, then this method will optionally call the callback itself and then return a return code to indicate that the target time has passed.</p>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this method from an IRQ handler (including alarm callbacks), and from either core.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the alarm pool to use for scheduling the callback (this determines which hardware alarm is used, and which core calls the callback) </td></tr>
    <tr><td class="paramname">time</td><td>the timestamp when (after which) the callback should fire </td></tr>
    <tr><td class="paramname">callback</td><td>the callback function </td></tr>
    <tr><td class="paramname">user_data</td><td>user data to pass to the callback function </td></tr>
    <tr><td class="paramname">fire_if_past</td><td>if true, and the alarm time falls before or during this call before the alarm can be set, then the callback should be called during (by) this function instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 the alarm id for an active (at the time of return) alarm </dd>
<dd>
0 if the alarm time passed before or during the call AND there is no active alarm to return the id of. The latter can either happen because fire_if_past was false (i.e. no timer was ever created), or if the callback <em>was</em> called during this method but the callback cancelled itself by returning 0 </dd>
<dd>
-1 if there were no alarm slots available </dd></dl>

</div>
</div>
<a id="ga72bfc8c2dd5bf334cd68af2e349a1b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72bfc8c2dd5bf334cd68af2e349a1b37">&#9670;&nbsp;</a></span>alarm_pool_add_alarm_at_force_in_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">alarm_id_t</a> alarm_pool_add_alarm_at_force_in_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalarm__pool.html">alarm_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structabsolute__time__t.html">absolute_time_t</a>&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__alarm.html#gade88ed45e9b59ad39d91f17c8709c16a">alarm_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an alarm callback to be called at or after a specific time. </p>
<p>The callback is called as soon as possible after the time specified from an IRQ handler on the core the alarm pool was created on. Unlike <a class="el" href="group__alarm.html#gab75446a927e4e870ad27fde145a88019">alarm_pool_add_alarm_at</a>, this method guarantees to call the callback from that core even if the time is during this method call or in the past.</p>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this method from an IRQ handler (including alarm callbacks), and from either core.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the alarm pool to use for scheduling the callback (this determines which hardware alarm is used, and which core calls the callback) </td></tr>
    <tr><td class="paramname">time</td><td>the timestamp when (after which) the callback should fire </td></tr>
    <tr><td class="paramname">callback</td><td>the callback function </td></tr>
    <tr><td class="paramname">user_data</td><td>user data to pass to the callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 the alarm id for an active (at the time of return) alarm </dd>
<dd>
-1 if there were no alarm slots available </dd></dl>

</div>
</div>
<a id="ga6e32765c525683f216fc42bd1984e239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e32765c525683f216fc42bd1984e239">&#9670;&nbsp;</a></span>alarm_pool_add_alarm_in_ms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">alarm_id_t</a> alarm_pool_add_alarm_in_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalarm__pool.html">alarm_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__alarm.html#gade88ed45e9b59ad39d91f17c8709c16a">alarm_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fire_if_past</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an alarm callback to be called after a delay specified in milliseconds. </p>
<p>Generally the callback is called as soon as possible after the time specified from an IRQ handler on the core the alarm pool was created on. If the callback is in the past or happens before the alarm setup could be completed, then this method will optionally call the callback itself and then return a return code to indicate that the target time has passed.</p>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this method from an IRQ handler (including alarm callbacks), and from either core.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the alarm pool to use for scheduling the callback (this determines which hardware alarm is used, and which core calls the callback) </td></tr>
    <tr><td class="paramname">ms</td><td>the delay (from now) in milliseconds when (after which) the callback should fire </td></tr>
    <tr><td class="paramname">callback</td><td>the callback function </td></tr>
    <tr><td class="paramname">user_data</td><td>user data to pass to the callback function </td></tr>
    <tr><td class="paramname">fire_if_past</td><td>if true, and the alarm time falls before or during this call before the alarm can be set, then the callback should be called during (by) this function instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 the alarm id </dd>
<dd>
0 if the alarm time passed before or during the call AND there is no active alarm to return the id of. The latter can either happen because fire_if_past was false (i.e. no timer was ever created), or if the callback <em>was</em> called during this method but the callback cancelled itself by returning 0 </dd>
<dd>
-1 if there were no alarm slots available </dd></dl>

</div>
</div>
<a id="ga0d00072e81de2d54fa690dc4b4bfe408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d00072e81de2d54fa690dc4b4bfe408">&#9670;&nbsp;</a></span>alarm_pool_add_alarm_in_us()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">alarm_id_t</a> alarm_pool_add_alarm_in_us </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalarm__pool.html">alarm_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__alarm.html#gade88ed45e9b59ad39d91f17c8709c16a">alarm_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fire_if_past</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an alarm callback to be called after a delay specified in microseconds. </p>
<p>Generally the callback is called as soon as possible after the time specified from an IRQ handler on the core the alarm pool was created on. If the callback is in the past or happens before the alarm setup could be completed, then this method will optionally call the callback itself and then return a return code to indicate that the target time has passed.</p>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this method from an IRQ handler (including alarm callbacks), and from either core.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the alarm pool to use for scheduling the callback (this determines which hardware alarm is used, and which core calls the callback) </td></tr>
    <tr><td class="paramname">us</td><td>the delay (from now) in microseconds when (after which) the callback should fire </td></tr>
    <tr><td class="paramname">callback</td><td>the callback function </td></tr>
    <tr><td class="paramname">user_data</td><td>user data to pass to the callback function </td></tr>
    <tr><td class="paramname">fire_if_past</td><td>if true, and the alarm time falls during this call before the alarm can be set, then the callback should be called during (by) this function instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 the alarm id </dd>
<dd>
0 if the alarm time passed before or during the call AND there is no active alarm to return the id of. The latter can either happen because fire_if_past was false (i.e. no timer was ever created), or if the callback <em>was</em> called during this method but the callback cancelled itself by returning 0 </dd>
<dd>
-1 if there were no alarm slots available </dd></dl>

</div>
</div>
<a id="ga02cc23b4a3109fb8c2d57e24981f2932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02cc23b4a3109fb8c2d57e24981f2932">&#9670;&nbsp;</a></span>alarm_pool_cancel_alarm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alarm_pool_cancel_alarm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalarm__pool.html">alarm_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">alarm_id_t</a>&#160;</td>
          <td class="paramname"><em>alarm_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel an alarm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the <a class="el" href="structalarm__pool.html">alarm_pool</a> containing the alarm </td></tr>
    <tr><td class="paramname">alarm_id</td><td>the alarm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the alarm was cancelled, false if it didn't exist </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b" title="The identifier for an alarm.">alarm_id_t</a> for a note on reuse of IDs </dd></dl>

</div>
</div>
<a id="ga4918e03a3ddd5c328d65bd014d26856b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4918e03a3ddd5c328d65bd014d26856b">&#9670;&nbsp;</a></span>alarm_pool_core_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint alarm_pool_core_num </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalarm__pool.html">alarm_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the core number the alarm pool was initialized on (and hence callbacks are called on) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the core used by the pool </dd></dl>

</div>
</div>
<a id="ga3caa6c4edd9fc97b5ea4688eabc3545d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3caa6c4edd9fc97b5ea4688eabc3545d">&#9670;&nbsp;</a></span>alarm_pool_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalarm__pool.html">alarm_pool_t</a>* alarm_pool_create </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>hardware_alarm_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>max_timers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an alarm pool. </p>
<p>The alarm pool will call callbacks from an alarm IRQ Handler on the core of this function is called from.</p>
<p>In many situations there is never any need for anything other than the default alarm pool, however you might want to create another if you want alarm callbacks on core 1 or require alarm pools of different priority (IRQ priority based preemption of callbacks)</p>
<dl class="section note"><dt>Note</dt><dd>This method will hard assert if the hardware alarm is already claimed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hardware_alarm_num</td><td>the hardware alarm to use to back this pool </td></tr>
    <tr><td class="paramname">max_timers</td><td>the maximum number of timers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For implementation reasons this is limited to PICO_PHEAP_MAX_ENTRIES which defaults to 255 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__alarm.html#ga3eb49d6478d51b0507d7f0bc2334374f" title="The default alarm pool used when alarms are added without specifying an alarm pool,...">alarm_pool_get_default()</a> </dd>
<dd>
hardware_claiming </dd></dl>

</div>
</div>
<a id="gae3d6256fbd5c3500984704092ae265fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3d6256fbd5c3500984704092ae265fc">&#9670;&nbsp;</a></span>alarm_pool_create_with_unused_hardware_alarm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalarm__pool.html">alarm_pool_t</a>* alarm_pool_create_with_unused_hardware_alarm </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>max_timers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an alarm pool, claiming an used hardware alarm to back it. </p>
<p>The alarm pool will call callbacks from an alarm IRQ Handler on the core of this function is called from.</p>
<p>In many situations there is never any need for anything other than the default alarm pool, however you might want to create another if you want alarm callbacks on core 1 or require alarm pools of different priority (IRQ priority based preemption of callbacks)</p>
<dl class="section note"><dt>Note</dt><dd>This method will hard assert if the there is no free hardware to claim.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_timers</td><td>the maximum number of timers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For implementation reasons this is limited to PICO_PHEAP_MAX_ENTRIES which defaults to 255 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__alarm.html#ga3eb49d6478d51b0507d7f0bc2334374f" title="The default alarm pool used when alarms are added without specifying an alarm pool,...">alarm_pool_get_default()</a> </dd>
<dd>
hardware_claiming </dd></dl>

</div>
</div>
<a id="gae7536c4d34088a2d19b2da92b87cbb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7536c4d34088a2d19b2da92b87cbb4e">&#9670;&nbsp;</a></span>alarm_pool_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alarm_pool_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalarm__pool.html">alarm_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the alarm pool, cancelling all alarms and freeing up the underlying hardware alarm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hardware alarm used by the pool </dd></dl>

</div>
</div>
<a id="ga3eb49d6478d51b0507d7f0bc2334374f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eb49d6478d51b0507d7f0bc2334374f">&#9670;&nbsp;</a></span>alarm_pool_get_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalarm__pool.html">alarm_pool_t</a>* alarm_pool_get_default </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default alarm pool used when alarms are added without specifying an alarm pool, and also used by the SDK to support lower power sleeps and timeouts. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__alarm.html#ga40b4a03bf9e967d4e7170d20c5c9fb15" title="Selects which hardware alarm is used for the default alarm pool.">PICO_TIME_DEFAULT_ALARM_POOL_HARDWARE_ALARM_NUM</a> </dd></dl>

</div>
</div>
<a id="ga2dc626c1e534842c85c3902d212f7eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2dc626c1e534842c85c3902d212f7eef">&#9670;&nbsp;</a></span>alarm_pool_hardware_alarm_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint alarm_pool_hardware_alarm_num </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalarm__pool.html">alarm_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the hardware alarm used by an alarm pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hardware alarm used by the pool </dd></dl>

</div>
</div>
<a id="gae99f63dc25fe5c3a0d78d9fb90308b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae99f63dc25fe5c3a0d78d9fb90308b1b">&#9670;&nbsp;</a></span>cancel_alarm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool cancel_alarm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b">alarm_id_t</a>&#160;</td>
          <td class="paramname"><em>alarm_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel an alarm from the default alarm pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alarm_id</td><td>the alarm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the alarm was cancelled, false if it didn't exist </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b" title="The identifier for an alarm.">alarm_id_t</a> for a note on reuse of IDs </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

	<script src="main.js"></script>
</body>
</html>