<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9"/>
	<meta name="generator" content="Doxygen 1.8.17"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>Raspberry Pi Pico SDK: hardware_irq</title>
	<!-- <link href="tabs.css" rel="stylesheet" type="text/css"/> -->
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
	<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
	<link href="doxygen.css" rel="stylesheet" type="text/css" />
	<link href="normalise.css" rel="stylesheet" type="text/css"/>
<link href="main.css" rel="stylesheet" type="text/css"/>
<link href="styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
	<div class="navigation-mobile">
		<div class="logo--mobile">
			<a href="/"><img src="logo-mobile.svg" alt="Raspberry Pi"></a>
		</div>
		<div class="navigation-toggle">
			<span class="line-1"></span>
			<span class="line-2">
				<p>Menu Toggle</p>
			</span>
			<span class="line-3"></span>
		</div>
	</div>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div class="logo">
			<a href="index.html"> <img src="logo.svg" alt="Raspberry Pi"></a>
			<span style="display: inline-block; margin-top: 10px;">
				v1.5.0
			</span>
		</div>
		<div class="navigation-footer">
			<img src="logo-mobile.svg" alt="Raspberry Pi">
			<a href="https://www.raspberrypi.com/" target="_blank">By Raspberry Pi Ltd</a>
		</div>
<!-- 		<div class="search">
			<form>
				<input type="search" name="search" id="search" placeholder="Search">
				<input type="submit" value="Search">
			</form>
		</div> -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__hardware__irq.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">hardware_irq<div class="ingroups"><a class="el" href="group__hardware.html">Hardware APIs</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Hardware interrupt handling.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga8478ee26cc144e947ccd75b0169059a6"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a>) (void)</td></tr>
<tr class="memdesc:ga8478ee26cc144e947ccd75b0169059a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt handler function type.  <a href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">More...</a><br /></td></tr>
<tr class="separator:ga8478ee26cc144e947ccd75b0169059a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad11ea172f11d9763647ac34b366ab3c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__irq.html#gad11ea172f11d9763647ac34b366ab3c2">irq_set_priority</a> (uint num, uint8_t hardware_priority)</td></tr>
<tr class="memdesc:gad11ea172f11d9763647ac34b366ab3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set specified interrupt's priority.  <a href="group__hardware__irq.html#gad11ea172f11d9763647ac34b366ab3c2">More...</a><br /></td></tr>
<tr class="separator:gad11ea172f11d9763647ac34b366ab3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bcde7d99ca71abe8dccfd13b4d80b29"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__irq.html#ga6bcde7d99ca71abe8dccfd13b4d80b29">irq_get_priority</a> (uint num)</td></tr>
<tr class="memdesc:ga6bcde7d99ca71abe8dccfd13b4d80b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get specified interrupt's priority.  <a href="group__hardware__irq.html#ga6bcde7d99ca71abe8dccfd13b4d80b29">More...</a><br /></td></tr>
<tr class="separator:ga6bcde7d99ca71abe8dccfd13b4d80b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c7167f643c6898b758340ce59d333d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__irq.html#ga7c7167f643c6898b758340ce59d333d9">irq_set_enabled</a> (uint num, bool enabled)</td></tr>
<tr class="memdesc:ga7c7167f643c6898b758340ce59d333d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable a specific interrupt on the executing core.  <a href="group__hardware__irq.html#ga7c7167f643c6898b758340ce59d333d9">More...</a><br /></td></tr>
<tr class="separator:ga7c7167f643c6898b758340ce59d333d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c54ae4c0593c2a8596b99cd167584e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__irq.html#ga0c54ae4c0593c2a8596b99cd167584e0">irq_is_enabled</a> (uint num)</td></tr>
<tr class="memdesc:ga0c54ae4c0593c2a8596b99cd167584e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a specific interrupt is enabled on the executing core.  <a href="group__hardware__irq.html#ga0c54ae4c0593c2a8596b99cd167584e0">More...</a><br /></td></tr>
<tr class="separator:ga0c54ae4c0593c2a8596b99cd167584e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae91340b84a6d70049933af657df93201"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__irq.html#gae91340b84a6d70049933af657df93201">irq_set_mask_enabled</a> (uint32_t mask, bool enabled)</td></tr>
<tr class="memdesc:gae91340b84a6d70049933af657df93201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable multiple interrupts on the executing core.  <a href="group__hardware__irq.html#gae91340b84a6d70049933af657df93201">More...</a><br /></td></tr>
<tr class="separator:gae91340b84a6d70049933af657df93201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafffd448ba2d2eef5b355b88180aefe7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__irq.html#gafffd448ba2d2eef5b355b88180aefe7f">irq_set_exclusive_handler</a> (uint num, <a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a> handler)</td></tr>
<tr class="memdesc:gafffd448ba2d2eef5b355b88180aefe7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an exclusive interrupt handler for an interrupt on the executing core.  <a href="group__hardware__irq.html#gafffd448ba2d2eef5b355b88180aefe7f">More...</a><br /></td></tr>
<tr class="separator:gafffd448ba2d2eef5b355b88180aefe7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42e9cdce7b82ef63c7b2416d32a42361"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__irq.html#ga42e9cdce7b82ef63c7b2416d32a42361">irq_get_exclusive_handler</a> (uint num)</td></tr>
<tr class="memdesc:ga42e9cdce7b82ef63c7b2416d32a42361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the exclusive interrupt handler for an interrupt on the executing core.  <a href="group__hardware__irq.html#ga42e9cdce7b82ef63c7b2416d32a42361">More...</a><br /></td></tr>
<tr class="separator:ga42e9cdce7b82ef63c7b2416d32a42361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf02f8599896c66f4579c845a96b2126e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__irq.html#gaf02f8599896c66f4579c845a96b2126e">irq_add_shared_handler</a> (uint num, <a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a> handler, uint8_t order_priority)</td></tr>
<tr class="memdesc:gaf02f8599896c66f4579c845a96b2126e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a shared interrupt handler for an interrupt on the executing core.  <a href="group__hardware__irq.html#gaf02f8599896c66f4579c845a96b2126e">More...</a><br /></td></tr>
<tr class="separator:gaf02f8599896c66f4579c845a96b2126e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfd3308952d41ee91671ae098b867a90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__irq.html#gadfd3308952d41ee91671ae098b867a90">irq_remove_handler</a> (uint num, <a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a> handler)</td></tr>
<tr class="memdesc:gadfd3308952d41ee91671ae098b867a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a specific interrupt handler for the given irq number on the executing core.  <a href="group__hardware__irq.html#gadfd3308952d41ee91671ae098b867a90">More...</a><br /></td></tr>
<tr class="separator:gadfd3308952d41ee91671ae098b867a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae552cab9da1b37a785791f678090f418"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__irq.html#gae552cab9da1b37a785791f678090f418">irq_has_shared_handler</a> (uint num)</td></tr>
<tr class="memdesc:gae552cab9da1b37a785791f678090f418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the current handler for the given number is shared.  <a href="group__hardware__irq.html#gae552cab9da1b37a785791f678090f418">More...</a><br /></td></tr>
<tr class="separator:gae552cab9da1b37a785791f678090f418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f9772d9d1781c3a28371623886a0310"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__irq.html#ga4f9772d9d1781c3a28371623886a0310">irq_get_vtable_handler</a> (uint num)</td></tr>
<tr class="memdesc:ga4f9772d9d1781c3a28371623886a0310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current IRQ handler for the specified IRQ from the currently installed hardware vector table (VTOR) of the execution core.  <a href="group__hardware__irq.html#ga4f9772d9d1781c3a28371623886a0310">More...</a><br /></td></tr>
<tr class="separator:ga4f9772d9d1781c3a28371623886a0310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14fa98b8bec09df3e7409a75cf2f5359"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__irq.html#ga14fa98b8bec09df3e7409a75cf2f5359">irq_clear</a> (uint int_num)</td></tr>
<tr class="memdesc:ga14fa98b8bec09df3e7409a75cf2f5359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a specific interrupt on the executing core.  <a href="group__hardware__irq.html#ga14fa98b8bec09df3e7409a75cf2f5359">More...</a><br /></td></tr>
<tr class="separator:ga14fa98b8bec09df3e7409a75cf2f5359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36e4b97d3414ce58c3091e63badcf9ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__irq.html#ga36e4b97d3414ce58c3091e63badcf9ce">irq_set_pending</a> (uint num)</td></tr>
<tr class="memdesc:ga36e4b97d3414ce58c3091e63badcf9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force an interrupt to be pending on the executing core.  <a href="group__hardware__irq.html#ga36e4b97d3414ce58c3091e63badcf9ce">More...</a><br /></td></tr>
<tr class="separator:ga36e4b97d3414ce58c3091e63badcf9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa52ec9e5f572b3a0ef50707ab37233ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__irq.html#gaa52ec9e5f572b3a0ef50707ab37233ef">user_irq_claim</a> (uint irq_num)</td></tr>
<tr class="memdesc:gaa52ec9e5f572b3a0ef50707ab37233ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Claim ownership of a user IRQ on the calling core.  <a href="group__hardware__irq.html#gaa52ec9e5f572b3a0ef50707ab37233ef">More...</a><br /></td></tr>
<tr class="separator:gaa52ec9e5f572b3a0ef50707ab37233ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14c041e05fbd5ee3c0b6b6341073a20a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__irq.html#ga14c041e05fbd5ee3c0b6b6341073a20a">user_irq_unclaim</a> (uint irq_num)</td></tr>
<tr class="memdesc:ga14c041e05fbd5ee3c0b6b6341073a20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a user IRQ as no longer used on the calling core.  <a href="group__hardware__irq.html#ga14c041e05fbd5ee3c0b6b6341073a20a">More...</a><br /></td></tr>
<tr class="separator:ga14c041e05fbd5ee3c0b6b6341073a20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace889ebb0bde6fc678dee915d4e3537e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__irq.html#gace889ebb0bde6fc678dee915d4e3537e">user_irq_claim_unused</a> (bool required)</td></tr>
<tr class="memdesc:gace889ebb0bde6fc678dee915d4e3537e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Claim ownership of a free user IRQ on the calling core.  <a href="group__hardware__irq.html#gace889ebb0bde6fc678dee915d4e3537e">More...</a><br /></td></tr>
<tr class="separator:gace889ebb0bde6fc678dee915d4e3537e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Hardware interrupt handling. </p>
<p>The RP2040 uses the standard ARM nested vectored interrupt controller (NVIC).</p>
<p>Interrupts are identified by a number from 0 to 31.</p>
<p>On the RP2040, only the lower 26 IRQ signals are connected on the NVIC; IRQs 26 to 31 are tied to zero (never firing).</p>
<p>There is one NVIC per core, and each core's NVIC has the same hardware interrupt lines routed to it, with the exception of the IO interrupts where there is one IO interrupt per bank, per core. These are completely independent, so, for example, processor 0 can be interrupted by GPIO 0 in bank 0, and processor 1 by GPIO 1 in the same bank.</p>
<dl class="section note"><dt>Note</dt><dd>That all IRQ APIs affect the executing core only (i.e. the core calling the function).</dd>
<dd>
You should not enable the same (shared) IRQ number on both cores, as this will lead to race conditions or starvation of one of the cores. Additionally, don't forget that disabling interrupts on one core does not disable interrupts on the other core.</dd></dl>
<p>There are three different ways to set handlers for an IRQ:</p><ul>
<li>Calling <a class="el" href="group__hardware__irq.html#gaf02f8599896c66f4579c845a96b2126e" title="Add a shared interrupt handler for an interrupt on the executing core.">irq_add_shared_handler()</a> at runtime to add a handler for a multiplexed interrupt (e.g. GPIO bank) on the current core. Each handler, should check and clear the relevant hardware interrupt source</li>
<li>Calling <a class="el" href="group__hardware__irq.html#gafffd448ba2d2eef5b355b88180aefe7f" title="Set an exclusive interrupt handler for an interrupt on the executing core.">irq_set_exclusive_handler()</a> at runtime to install a single handler for the interrupt on the current core</li>
<li>Defining the interrupt handler explicitly in your application (e.g. by defining void <code>isr_dma_0</code> will make that function the handler for the DMA_IRQ_0 on core 0, and you will not be able to change it using the above APIs at runtime). Using this method can cause link conflicts at runtime, and offers no runtime performance benefit (i.e, it should not generally be used).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If an IRQ is enabled and fires with no handler installed, a breakpoint will be hit and the IRQ number will be in register r0.</dd></dl>
<h1><a class="anchor" id="interrupt_nums"></a>
Interrupt Numbers</h1>
<p>Interrupts are numbered as follows, a set of defines is available (intctrl.h) with these names to avoid using the numbers directly.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">IRQ </th><th class="markdownTableHeadNone">Interrupt Source  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0 </td><td class="markdownTableBodyNone">TIMER_IRQ_0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1 </td><td class="markdownTableBodyNone">TIMER_IRQ_1  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2 </td><td class="markdownTableBodyNone">TIMER_IRQ_2  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3 </td><td class="markdownTableBodyNone">TIMER_IRQ_3  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4 </td><td class="markdownTableBodyNone">PWM_IRQ_WRAP  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">5 </td><td class="markdownTableBodyNone">USBCTRL_IRQ  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">6 </td><td class="markdownTableBodyNone">XIP_IRQ  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">7 </td><td class="markdownTableBodyNone">PIO0_IRQ_0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">PIO0_IRQ_1  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">9 </td><td class="markdownTableBodyNone">PIO1_IRQ_0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10 </td><td class="markdownTableBodyNone">PIO1_IRQ_1  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">11 </td><td class="markdownTableBodyNone">DMA_IRQ_0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">12 </td><td class="markdownTableBodyNone">DMA_IRQ_1  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">13 </td><td class="markdownTableBodyNone">IO_IRQ_BANK0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">14 </td><td class="markdownTableBodyNone">IO_IRQ_QSPI  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">15 </td><td class="markdownTableBodyNone">SIO_IRQ_PROC0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">16 </td><td class="markdownTableBodyNone">SIO_IRQ_PROC1  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">17 </td><td class="markdownTableBodyNone">CLOCKS_IRQ  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">18 </td><td class="markdownTableBodyNone">SPI0_IRQ  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">19 </td><td class="markdownTableBodyNone">SPI1_IRQ  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">20 </td><td class="markdownTableBodyNone">UART0_IRQ  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">21 </td><td class="markdownTableBodyNone">UART1_IRQ  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">22 </td><td class="markdownTableBodyNone">ADC0_IRQ_FIFO  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">23 </td><td class="markdownTableBodyNone">I2C0_IRQ  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">24 </td><td class="markdownTableBodyNone">I2C1_IRQ  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">25 </td><td class="markdownTableBodyNone">RTC_IRQ  </td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga8478ee26cc144e947ccd75b0169059a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8478ee26cc144e947ccd75b0169059a6">&#9670;&nbsp;</a></span>irq_handler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* irq_handler_t) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt handler function type. </p>
<p>All interrupts handlers should be of this type, and follow normal ARM EABI register saving conventions </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf02f8599896c66f4579c845a96b2126e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf02f8599896c66f4579c845a96b2126e">&#9670;&nbsp;</a></span>irq_add_shared_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void irq_add_shared_handler </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>order_priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a shared interrupt handler for an interrupt on the executing core. </p>
<p>Use this method to add a handler on an irq number shared between multiple distinct hardware sources (e.g. GPIO, DMA or PIO IRQs). Handlers added by this method will all be called in sequence from highest order_priority to lowest. The <a class="el" href="group__hardware__irq.html#gafffd448ba2d2eef5b355b88180aefe7f" title="Set an exclusive interrupt handler for an interrupt on the executing core.">irq_set_exclusive_handler()</a> method should be used instead if you know there will or should only ever be one handler for the interrupt.</p>
<p>This method will assert if there is an exclusive interrupt handler set for this irq number on this core, or if the (total across all IRQs on both cores) maximum (configurable via PICO_MAX_SHARED_IRQ_HANDLERS) number of shared handlers would be exceeded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Interrupt number <a class="el" href="group__hardware__irq.html#interrupt_nums">Interrupt Numbers</a> </td></tr>
    <tr><td class="paramname">handler</td><td>The handler to set. See <a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a> </td></tr>
    <tr><td class="paramname">order_priority</td><td>The order priority controls the order that handlers for the same IRQ number on the core are called. The shared irq handlers for an interrupt are all called when an IRQ fires, however the order of the calls is based on the order_priority (higher priorities are called first, identical priorities are called in undefined order). A good rule of thumb is to use PICO_SHARED_IRQ_HANDLER_DEFAULT_ORDER_PRIORITY if you don't much care, as it is in the middle of the priority range by default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The order_priority uses <em>higher</em> values for higher priorities which is the <em>opposite</em> of the CPU interrupt priorities passed to <a class="el" href="group__hardware__irq.html#gad11ea172f11d9763647ac34b366ab3c2" title="Set specified interrupt&#39;s priority.">irq_set_priority()</a> which use lower values for higher priorities.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__hardware__irq.html#gafffd448ba2d2eef5b355b88180aefe7f" title="Set an exclusive interrupt handler for an interrupt on the executing core.">irq_set_exclusive_handler()</a> </dd></dl>

</div>
</div>
<a id="ga14fa98b8bec09df3e7409a75cf2f5359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14fa98b8bec09df3e7409a75cf2f5359">&#9670;&nbsp;</a></span>irq_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void irq_clear </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>int_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear a specific interrupt on the executing core. </p>
<p>This method is only useful for "software" IRQs that are not connected to hardware (i.e. IRQs 26-31) as the the NVIC always reflects the current state of the IRQ state of the hardware for hardware IRQs, and clearing of the IRQ state of the hardware is performed via the hardware's registers instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int_num</td><td>Interrupt number <a class="el" href="group__hardware__irq.html#interrupt_nums">Interrupt Numbers</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga42e9cdce7b82ef63c7b2416d32a42361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42e9cdce7b82ef63c7b2416d32a42361">&#9670;&nbsp;</a></span>irq_get_exclusive_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a> irq_get_exclusive_handler </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the exclusive interrupt handler for an interrupt on the executing core. </p>
<p>This method will return an exclusive IRQ handler set on this core by irq_set_exclusive_handler if there is one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Interrupt number <a class="el" href="group__hardware__irq.html#interrupt_nums">Interrupt Numbers</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__hardware__irq.html#gafffd448ba2d2eef5b355b88180aefe7f" title="Set an exclusive interrupt handler for an interrupt on the executing core.">irq_set_exclusive_handler()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>handler The handler if an exclusive handler is set for the IRQ, NULL if no handler is set or shared/shareable handlers are installed </dd></dl>

</div>
</div>
<a id="ga6bcde7d99ca71abe8dccfd13b4d80b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bcde7d99ca71abe8dccfd13b4d80b29">&#9670;&nbsp;</a></span>irq_get_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint irq_get_priority </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get specified interrupt's priority. </p>
<p>Numerically-lower values indicate a higher priority. Hardware priorities range from 0 (highest priority) to 255 (lowest priority) though only the top 2 bits are significant on ARM Cortex-M0+. To make it easier to specify higher or lower priorities than the default, all IRQ priorities are initialized to PICO_DEFAULT_IRQ_PRIORITY by the SDK runtime at startup. PICO_DEFAULT_IRQ_PRIORITY defaults to 0x80</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Interrupt number <a class="el" href="group__hardware__irq.html#interrupt_nums">Interrupt Numbers</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the IRQ priority </dd></dl>

</div>
</div>
<a id="ga4f9772d9d1781c3a28371623886a0310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f9772d9d1781c3a28371623886a0310">&#9670;&nbsp;</a></span>irq_get_vtable_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a> irq_get_vtable_handler </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current IRQ handler for the specified IRQ from the currently installed hardware vector table (VTOR) of the execution core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Interrupt number <a class="el" href="group__hardware__irq.html#interrupt_nums">Interrupt Numbers</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address stored in the VTABLE for the given irq number </dd></dl>

</div>
</div>
<a id="gae552cab9da1b37a785791f678090f418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae552cab9da1b37a785791f678090f418">&#9670;&nbsp;</a></span>irq_has_shared_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool irq_has_shared_handler </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the current handler for the given number is shared. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Interrupt number <a class="el" href="group__hardware__irq.html#interrupt_nums">Interrupt Numbers</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the specified IRQ has a shared handler </dd></dl>

</div>
</div>
<a id="ga0c54ae4c0593c2a8596b99cd167584e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c54ae4c0593c2a8596b99cd167584e0">&#9670;&nbsp;</a></span>irq_is_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool irq_is_enabled </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a specific interrupt is enabled on the executing core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Interrupt number <a class="el" href="group__hardware__irq.html#interrupt_nums">Interrupt Numbers</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the interrupt is enabled </dd></dl>

</div>
</div>
<a id="gadfd3308952d41ee91671ae098b867a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfd3308952d41ee91671ae098b867a90">&#9670;&nbsp;</a></span>irq_remove_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void irq_remove_handler </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a specific interrupt handler for the given irq number on the executing core. </p>
<p>This method may be used to remove an irq set via either <a class="el" href="group__hardware__irq.html#gafffd448ba2d2eef5b355b88180aefe7f" title="Set an exclusive interrupt handler for an interrupt on the executing core.">irq_set_exclusive_handler()</a> or <a class="el" href="group__hardware__irq.html#gaf02f8599896c66f4579c845a96b2126e" title="Add a shared interrupt handler for an interrupt on the executing core.">irq_add_shared_handler()</a>, and will assert if the handler is not currently installed for the given IRQ number</p>
<dl class="section note"><dt>Note</dt><dd>This method may <em>only</em> be called from user (non IRQ code) or from within the handler itself (i.e. an IRQ handler may remove itself as part of handling the IRQ). Attempts to call from another IRQ will cause an assertion.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Interrupt number <a class="el" href="group__hardware__irq.html#interrupt_nums">Interrupt Numbers</a> </td></tr>
    <tr><td class="paramname">handler</td><td>The handler to removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__hardware__irq.html#gafffd448ba2d2eef5b355b88180aefe7f" title="Set an exclusive interrupt handler for an interrupt on the executing core.">irq_set_exclusive_handler()</a> </dd>
<dd>
<a class="el" href="group__hardware__irq.html#gaf02f8599896c66f4579c845a96b2126e" title="Add a shared interrupt handler for an interrupt on the executing core.">irq_add_shared_handler()</a> </dd></dl>

</div>
</div>
<a id="ga7c7167f643c6898b758340ce59d333d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c7167f643c6898b758340ce59d333d9">&#9670;&nbsp;</a></span>irq_set_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void irq_set_enabled </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable a specific interrupt on the executing core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Interrupt number <a class="el" href="group__hardware__irq.html#interrupt_nums">Interrupt Numbers</a> </td></tr>
    <tr><td class="paramname">enabled</td><td>true to enable the interrupt, false to disable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafffd448ba2d2eef5b355b88180aefe7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafffd448ba2d2eef5b355b88180aefe7f">&#9670;&nbsp;</a></span>irq_set_exclusive_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void irq_set_exclusive_handler </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an exclusive interrupt handler for an interrupt on the executing core. </p>
<p>Use this method to set a handler for single IRQ source interrupts, or when your code, use case or performance requirements dictate that there should no other handlers for the interrupt.</p>
<p>This method will assert if there is already any sort of interrupt handler installed for the specified irq number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Interrupt number <a class="el" href="group__hardware__irq.html#interrupt_nums">Interrupt Numbers</a> </td></tr>
    <tr><td class="paramname">handler</td><td>The handler to set. See <a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__hardware__irq.html#gaf02f8599896c66f4579c845a96b2126e" title="Add a shared interrupt handler for an interrupt on the executing core.">irq_add_shared_handler()</a> </dd></dl>

</div>
</div>
<a id="gae91340b84a6d70049933af657df93201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae91340b84a6d70049933af657df93201">&#9670;&nbsp;</a></span>irq_set_mask_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void irq_set_mask_enabled </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable multiple interrupts on the executing core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>32-bit mask with one bits set for the interrupts to enable/disable <a class="el" href="group__hardware__irq.html#interrupt_nums">Interrupt Numbers</a> </td></tr>
    <tr><td class="paramname">enabled</td><td>true to enable the interrupts, false to disable them. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga36e4b97d3414ce58c3091e63badcf9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36e4b97d3414ce58c3091e63badcf9ce">&#9670;&nbsp;</a></span>irq_set_pending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void irq_set_pending </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force an interrupt to be pending on the executing core. </p>
<p>This should generally not be used for IRQs connected to hardware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Interrupt number <a class="el" href="group__hardware__irq.html#interrupt_nums">Interrupt Numbers</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad11ea172f11d9763647ac34b366ab3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad11ea172f11d9763647ac34b366ab3c2">&#9670;&nbsp;</a></span>irq_set_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void irq_set_priority </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>hardware_priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set specified interrupt's priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Interrupt number <a class="el" href="group__hardware__irq.html#interrupt_nums">Interrupt Numbers</a> </td></tr>
    <tr><td class="paramname">hardware_priority</td><td>Priority to set. Numerically-lower values indicate a higher priority. Hardware priorities range from 0 (highest priority) to 255 (lowest priority) though only the top 2 bits are significant on ARM Cortex-M0+. To make it easier to specify higher or lower priorities than the default, all IRQ priorities are initialized to PICO_DEFAULT_IRQ_PRIORITY by the SDK runtime at startup. PICO_DEFAULT_IRQ_PRIORITY defaults to 0x80 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa52ec9e5f572b3a0ef50707ab37233ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa52ec9e5f572b3a0ef50707ab37233ef">&#9670;&nbsp;</a></span>user_irq_claim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void user_irq_claim </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>irq_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Claim ownership of a user IRQ on the calling core. </p>
<p>User IRQs are numbered 26-31 and are not connected to any hardware, but can be triggered by <a class="el" href="group__hardware__irq.html#ga36e4b97d3414ce58c3091e63badcf9ce">irq_set_pending</a>.</p>
<dl class="section note"><dt>Note</dt><dd>User IRQs are a core local feature; they cannot be used to communicate between cores. Therfore all functions dealing with Uer IRQs affect only the calling core</dd></dl>
<p>This method explicitly claims ownership of a user IRQ, so other code can know it is being used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irq_num</td><td>the user IRQ to claim </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gace889ebb0bde6fc678dee915d4e3537e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace889ebb0bde6fc678dee915d4e3537e">&#9670;&nbsp;</a></span>user_irq_claim_unused()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int user_irq_claim_unused </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Claim ownership of a free user IRQ on the calling core. </p>
<p>User IRQs are numbered 26-31 and are not connected to any hardware, but can be triggered by <a class="el" href="group__hardware__irq.html#ga36e4b97d3414ce58c3091e63badcf9ce">irq_set_pending</a>.</p>
<dl class="section note"><dt>Note</dt><dd>User IRQs are a core local feature; they cannot be used to communicate between cores. Therfore all functions dealing with Uer IRQs affect only the calling core</dd></dl>
<p>This method explicitly claims ownership of an unused user IRQ if there is one, so other code can know it is being used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">required</td><td>if true the function will panic if none are available </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the user IRQ number or -1 if required was false, and none were free </dd></dl>

</div>
</div>
<a id="ga14c041e05fbd5ee3c0b6b6341073a20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14c041e05fbd5ee3c0b6b6341073a20a">&#9670;&nbsp;</a></span>user_irq_unclaim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void user_irq_unclaim </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>irq_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a user IRQ as no longer used on the calling core. </p>
<p>User IRQs are numbered 26-31 and are not connected to any hardware, but can be triggered by <a class="el" href="group__hardware__irq.html#ga36e4b97d3414ce58c3091e63badcf9ce">irq_set_pending</a>.</p>
<dl class="section note"><dt>Note</dt><dd>User IRQs are a core local feature; they cannot be used to communicate between cores. Therfore all functions dealing with Uer IRQs affect only the calling core</dd></dl>
<p>This method explicitly releases ownership of a user IRQ, so other code can know it is free to use.</p>
<dl class="section note"><dt>Note</dt><dd>it is customary to have disabled the irq and removed the handler prior to calling this method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irq_num</td><td>the irq irq_num to unclaim </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

	<script src="main.js"></script>
</body>
</html>